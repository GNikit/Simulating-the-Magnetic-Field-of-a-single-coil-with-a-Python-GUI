from typing import Tuple
import numpy as np
from mayavi import mlab
from mayavi.modules.iso_surface import IsoSurface
from mayavi.modules.streamline import Streamline
from scipy import special


class MagneticField(object):
    def __init__(self) -> None:
        pass

    @staticmethod
    def sphere_el(radius: float, current: float) -> None:
        Lx = Ly = Lz = radius * 4
        sp = 50j  # grid spacing (complex number for mgrid implies inclusive bound)
        x, y, z = np.mgrid[-Lx:Lx:sp, -Ly:Ly:sp, -Lz:Lz:sp]
        B = MagneticField.magnetic_field_single_coil(x, y, z, radius, current)

        fig = mlab.figure(1, size=(800, 600), bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))
        MagneticField.draw_coil(radius)

        objs = MagneticField.scene_setup(x, y, z, B[0], B[1], B[2], seedtype="sphere")
        # objs["streamlines"].seed.widget.phi_resolution = 10
        # objs["streamlines"].seed.widget.theta_resolution = 10
        objs["streamlines"].seed.widget.radius = radius

        MagneticField.scene_style(objs)

    @staticmethod
    def plane_el(radius: float, current: float) -> None:
        Lx = Ly = Lz = radius * 4
        sp = 50j  # grid spacing (complex number for mgrid implies inclusive bound)
        x, y, z = np.mgrid[-Lx:Lx:sp, -Ly:Ly:sp, -Lz:Lz:sp]
        Bx, By, Bz = MagneticField.magnetic_field_single_coil(x, y, z, radius, current)

        fig = mlab.figure(1, size=(800, 600), bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))
        MagneticField.draw_coil(radius)

        objs = MagneticField.scene_setup(x, y, z, Bx, By, Bz, seedtype="plane")
        objs["streamlines"].stream_tracer.maximum_propagation = 40.0
        objs["streamlines"].seed.widget.resolution = 20
        objs["streamlines"].seed.widget.handle_size = 0.5
        objs["streamlines"].seed.widget.representation = "outline"

        MagneticField.scene_style(objs)

    @staticmethod
    def line_el(radius: float, current: float) -> None:
        Lx = Ly = Lz = radius * 4
        sp = 50j  # grid spacing (complex number for mgrid implies inclusive bound)
        x, y, z = np.mgrid[-Lx:Lx:sp, -Ly:Ly:sp, -Lz:Lz:sp]
        Bx, By, Bz = MagneticField.magnetic_field_single_coil(x, y, z, radius, current)

        fig = mlab.figure(1, size=(800, 600), bgcolor=(1, 1, 1), fgcolor=(0, 0, 0))
        MagneticField.draw_coil(radius)

        objs = MagneticField.scene_setup(x, y, z, Bx, By, Bz, seedtype="line")
        objs["streamlines"].stream_tracer.maximum_propagation = 150
        objs["streamlines"].seed.widget.resolution = 30
        # objs["streamlines"].seed.widget.point1 = [95, 100.5, 100]  # placing seed
        # objs["streamlines"].seed.widget.point2 = [105, 100.5, 100]

        MagneticField.scene_style(objs)

    @staticmethod
    def draw_coil(
        radius: float,
        name="Coil",
        color=(0, 0, 1),
        centre: np.array = np.array([0, 0, 0]),
        scale: np.array = np.array([1, 1, 1]),
    ):
        l = 40
        theta = np.linspace(0, 2 * np.pi, l)
        y = ((radius * np.sin(theta)) + centre[0]) * scale[0]
        x = ((radius * np.cos(theta)) + centre[1]) * scale[1]
        z = (np.zeros(l) + centre[2]) * scale[2]
        return mlab.plot3d(
            x,
            y,
            z,
            name=name,
            tube_radius=radius * 0.1,
            color=color,
        )

    @staticmethod
    def magnetic_field_single_coil(
        x: np.ndarray,
        y: np.ndarray,
        z: np.ndarray,
        radius: float,
        current: float,
        normalise: bool = False,
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Calculate the magnetic field of a single coil loop

        The equations in Cylindrical coordinates are given by:
        .. math::
        B_z = \frac{\mu_0I}{2\pi}\frac{1}{[(R + \rho)^2 + z^2]^{1/2}} \times
            \left[K(k^2)+\frac{R^2 - \rho^2 - z^2}{(R-\rho)^2 + z^2}E(k^2)\right]
        B_\rho = \frac{\mu_0I}{2\pi\rho} \frac{z}{[R+\rho)^2 +z^2]^{1/2}} \times
            \left[-K(k^2) + E(k^2)\frac{R^2+\rho^2+z^2}{(R-\rho)^2+z^2}\right]

        where K and E are the elliptic integrals

        Args:
            x (np.ndarray): generated by `np.mgrid`
            y (np.ndarray): generated by `np.mgrid`
            z (np.ndarray): generated by `np.mgrid`
            radius (float): radius of the coil
            current (float): current through the coil
            normalise (bool, optional): normalise field. Defaults to False.

        Returns:
            Tuple[np.ndarray, np.ndarray, np.ndarray]: Magnetic field in Cartesian coordinates
        """

        R = radius
        I = current
        if abs(radius) < 1e-10:
            R = 1e-10
        if abs(current) < 1e-10:
            I = 1e-10

        rho = np.sqrt(x ** 2 + y ** 2)

        mu = 4 * np.pi * 10.0 ** (-7)  # Î¼0 constant
        Bz_norm_factor = 1
        Brho_norm_factor = 1
        if normalise:
            Bz_norm_factor = mu / (2 * np.pi)
            Brho_norm_factor = Bz_norm_factor / rho

        # Special ellipse E and K
        E = special.ellipe((4 * R * rho) / ((R + rho) ** 2 + z ** 2))
        K = special.ellipk((4 * R * rho) / ((R + rho) ** 2 + z ** 2))
        Bz = (
            I
            * Bz_norm_factor
            / (np.sqrt((R + rho) ** 2 + z ** 2))
            * (K + (R ** 2 - rho ** 2 - z ** 2) / ((R - rho) ** 2 + z ** 2) * E)
        )
        Brho = (
            I
            * Brho_norm_factor
            * z
            / (rho * np.sqrt((R + rho) ** 2 + z ** 2))
            * (-K + (R ** 2 + rho ** 2 + z ** 2) / ((R - rho) ** 2 + z ** 2) * E)
        )

        # At origin we get division by zero which yields NaN, physically the
        # field is zero in that location
        Brho[np.isnan(Brho)] = 0
        Brho[np.isinf(Brho)] = 0
        Bz[np.isnan(Bz)] = 0
        Bz[np.isinf(Bz)] = 0

        Bx, By = (x / rho) * Brho, (y / rho) * Brho

        del Brho, E, K

        return np.array([Bx, By, Bz])

    @staticmethod
    def scene_setup(
        x: np.ndarray,
        y: np.ndarray,
        z: np.ndarray,
        Bx: np.ndarray,
        By: np.ndarray,
        Bz: np.ndarray,
        seedtype: str,
    ) -> dict:
        field = mlab.pipeline.vector_field(x, y, z, Bx, By, Bz, name="B field")
        magnitude = mlab.pipeline.extract_vector_norm(field)
        contours: IsoSurface = mlab.pipeline.iso_surface(
            magnitude,
            contours=3,
            transparent=True,
            opacity=0.6,
            colormap="YlGnBu",
            # vmin=0,
            # vmax=0.5,
        )

        streamlines: Streamline = mlab.pipeline.streamline(
            magnitude,
            seedtype=seedtype,
            integration_direction="both",
            transparent=True,
            opacity=0.2,
            colormap="jet",
            # vmin=0,
            # vmax=0.5,
        )

        contours.actor.property.frontface_culling = True
        contours.normals.filter.feature_angle = 90

        streamlines.stream_tracer.maximum_propagation = 150

        pipeline_obj = {
            "field": field,
            "mag": magnitude,
            "contours": contours,
            "streamlines": streamlines,
        }

        return pipeline_obj

    @staticmethod
    @mlab.show
    def scene_style(objs: dict, **kwargs) -> None:
        sc = mlab.scalarbar(
            objs["streamlines"],
            title="Field\nStrength [T]",
            orientation="vertical",
            nb_labels=4,
        )
        # horizontal and vertical position from left->right, bottom->top
        sc.scalar_bar_representation.position = np.array([0.85, 0.1])
        # width and height of colourbar
        sc.scalar_bar_representation.position2 = np.array([0.1, 0.8])
        # The title of colourbar does not scale so we need to manually set it
        sc.scalar_bar.unconstrained_font_size = True
        sc.title_text_property.font_size = 20
        sc.label_text_property.font_size = 20
        ax = mlab.axes()
        mlab.view(azimuth=42, elevation=73)


if __name__ == "__main__":
    MagneticField.sphere_el(1.0, 1.0)
    MagneticField.plane_el(1.0, 0.1)
    MagneticField.line_el(1.0, 0.1)
